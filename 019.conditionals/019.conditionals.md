# Условия (if/elif/else)

- [Условия (if/elif/else)](#условия-ifelifelse)
  - [Описание](#описание)
  - [Логические выражения](#логические-выражения)
    - [Булев тип](#булев-тип)
    - [Приведение типов](#приведение-типов)
    - [Логические операторы](#логические-операторы)
    - [Операторы сравнения](#операторы-сравнения)
    - [`in`, `not in` - проверка наличия элемента в коллекции](#in-not-in---проверка-наличия-элемента-в-коллекции)
    - [`is` - сравнение объектов на идентичность](#is---сравнение-объектов-на-идентичность)
  - [Приоритет операций](#приоритет-операций)
  - [`any()`, `all()`](#any-all)
  - [`if`](#if)
  - [`elif`](#elif)
  - [`else`](#else)
  - [Тернарный оператор](#тернарный-оператор)

## Описание

Условные конструкции позволяют менять логику выполнения программы. Делать ветвления и включать или выключать блоки кода на основании логических условий.

## Логические выражения

### Булев тип

`True` и  `False` это самые простые и очевидные значения.

### Приведение типов

В python существует явное и неявное преобразование типов. Явное используется когда нам нужно в явном виде получить значение булева типа. При неявном преобразовании типов python автоматически преобразует один тип данных в другой. Этот процесс не требует участия пользователя. При неявном преобразовании типов:

- `True`
  - любое число, не равное 0
  - или любой непустой объект, например непустая строка, не пустой список
- `False`
  - число, равное 0 (0, 0.0, ...)
  - пустые объекты, ("" - пустая строка, [] - пустой список, [""] - при этом не пустой и результат будет `True`)
  - `None` (NoneType)
  
Можно проверить результат используя приведение типов:

```python
In [186]: bool("router1")
Out[186]: True

In [187]: bool("")
Out[187]: False

In [188]: bool([1, 2])
Out[188]: True

In [189]: bool([])
Out[189]: False

In [190]: bool([""])
Out[190]: True

In [191]: bool(43)
Out[191]: True

In [192]: bool(0.0)
Out[192]: False

In [193]: bool(None)
Out[193]: False
```

### Логические операторы

`and`, `or`, `not` - логические И, ИЛИ, НЕ.

```python
In [216]: device = {"password": "cisco", "ip": "192.168.1.2"}

In [217]: device.get("password") or "UNKNOWN"
Out[217]: 'cisco'

In [218]: device.get("username") or "UNKNOWN"
Out[218]: 'UNKNOWN'
```

> в python логические выражения "ленивые", т.е. если нужно вычислить `A and B`, если A = False, то результат сразу будет равен False, B не будет проверяться.

### Операторы сравнения

```python
In [201]: 4 > 2
Out[201]: True

In [202]: 4 < 2
Out[202]: False

In [203]: 4 != 2
Out[203]: True

In [204]: 4 == 2
Out[204]: False
```

```python
In [21]: my_list = [1, 2, 3]

In [22]: len(my_list) != 0
Out[22]: True
```

### `in`, `not in` - проверка наличия элемента в коллекции

`in` - возвращает `True` если элемент есть в коллекции, и `False` если нет

`not in` - "комбинация" логического оператора `not` и `in`

```python
In [23]: vlans = [200, 300, 500]

In [24]: 300 in vlans
Out[24]: True

In [25]: 400 in vlans
Out[25]: False

In [26]: 400 not in vlans
Out[26]: True
```

```python
In [6]: my_list = ["a", "b", "c"]

In [7]: not "a" in my_list == "a" not in my_list
Out[7]: True
```

### `is` - сравнение объектов на идентичность

Обычно используется только для сравнения с `None`, т.к. `None` существуют в единственном экземпляре и все переменные со значением `Nonе` ссылаются на один и тот же объект в памяти.

```python
In [27]: device = {"password": "cisco", "ip": "192.168.1.2"}

In [28]: device.get("username") is None
Out[28]: True
```

## Приоритет операций

Вычисления производятся слева направо, согласно приоритетности операторов

| Оператор | Описание |
|----------|----------|
| `()` | скобки |
| `**` | возведение в степень |
| `+x`, `-x` | унарные плюс и минус |
| `*`, `/`, `//`, `%` | умножение, деление, деление с остатком, остаток |
| `+`, `-` | сложение, вычитание |
| `==`, `!=`, `>`, `>=`, `<`, `<=`, `is`, `is not`, `in`, `not in` | сравнение, проверка вхождения и идентичности |
| `not` | логическое отрицание |
| `and` | логическое И |
| `or` | логическое ИЛИ |

В сложных (составных) выражениях:

- `or` возвращает первый слева элемент, который может быть преобразован в True, если такого нет - последний элемент

    ```python
    In [33]: 0 or False or [] or "test" or 15
    Out[33]: 'test'

    In [37]: 0 or False or [] or ""
    Out[37]: ''
    ```

- `and` возвращает первый элемент слева, который можно преобразовать в False, если такого нет - последний элемент

    ```python
    In [34]: 42 and "Hello" and [] and 0
    Out[34]: []

    In [35]: 42 and "Hello" and ["12"] and 3
    Out[35]: 3
    ```

```python
# 10 % 2 = 0 -> 0 == 0 -> True
# True and "even" -> "even", and возвращает последнее значение,
#   которое эквивалентно True
# or возвращает первое слева значение, которое эквивалентно True,
#   -> результат = "even"
In [40]: print(10 % 2 == 0 and "even" or "odd")
even

# 11 % 2 = 1 -> 1 == 0 -> False
# False and "even" -> False, and возвращает первое значение,
#   которое эквивалентно False
# or возвращает первое слева значение, которое эквивалентно True,
#   -> результат = (False or "odd")
In [41]: print(11 % 2 == 0 and "even" or "odd")
odd
```

При этом нельзя использовать скобки для сокращения записи:

```python
In [46]: value = "2nd"

In [47]: value == ("1st" or "2nd")
Out[47]: False

In [48]: value == "1st" or value == "2nd"
Out[48]: True
```

## `any()`, `all()`

Функции `any` и `all` служат для проверки истинности элементов в последовательности. При этом в `any` используется `or` между элементами последовательности, а в `all` - `and`.

```python
In [51]: device = {"host": "rt1.my.lab.com", "username": "cisco"}

In [52]: all(
    ...:     [
    ...:         device.get("host"),  # >> "rt1.my.lab.com" -> True
    ...:         device.get("username"),  # >> "cisco" -> True
    ...:         device.get("password"),  # >> None -> False
    ...:     ]
    ...: )
Out[52]: False

In [53]: all([device.get("host"), device.get("username"), device.get("password")])
Out[53]: False


In [54]: any(
    ...:     [
    ...:         device.get("host"),
    ...:         device.get("username"),
    ...:         device.get("password"),
    ...:     ]
    ...: )
Out[54]: True
```

## `if`

```python
In [181]: name = "rt1"

In [182]: if name == "rt1":
     ...:     print("router")
     ...: 
router
```

`name == "rt1"` - условное выражение, если результат `True`, тогда код внутри блока будет выполнен, если `False` - пропущен.

`if` задает начало условной секции.  
`:` в конце строки говорят, что код ниже будет во вложенном блоке, вложенность закончится, когда строка кода сдвинется обратно на уровень, на котором находится `if`

```python
if <условное выражение>:
    <блок кода, выполняемый, если условное выражение истина>

<код на уровне `if`, т.е. он не входит в условную секцию и будет выполнен всегда, независимо от значения условного выражения>
```

В качестве условных выражений могут быть любые комбинации, рассмотренные выше.

```python
In [207]: my_list = [1, 2, 3]

In [208]: if len(my_list) != 0:
     ...:     print("лист содержит элементы")
     ...: 
лист содержит элементы

In [213]: if vlan in vlans:
     ...:     print(f"vlan{vlan} включен на интерфейсе")
     ...: 
vlan300 включен на интерфейсе
```

Если потребуется, то будет работать неявное преобразование типов

```python
In [195]: my_list = [1, 2, 3]
In [196]: if my_list:
     ...:     print("лист содержит элементы")
лист содержит элементы
```

Все правила условных выражений работают и для блока `if`

```python
In [198]: if my_list and 0:
     ...:     print("блок никогда не будет исполнен")
     ...:
```

```python
In [199]: if [] or not 0:
     ...:     print("блок будет исполнен всегда")
     ...: 
блок будет исполнен всегда
```

## `elif`

Альтернативный `if`. Необязательный блок. Если нужно создать несколько веток кода, тогда в качестве второй и последующей проверки используется `elif`.

```python
In [232]: a = 5
     ...: if a > 20:
     ...:     print(f"{a} больше 20")
     ...: elif a < 10:
     ...:     print(f"{a} меньше 10")
     ...: 
5 меньше 10

### ===

In [55]: vendor = "arista"
In [56]: if vendor == "huawei":
    ...:     cmd = "display version"
    ...: elif vendor == "arista":
    ...:     cmd = "show version"
    ...: 

In [57]: print(cmd)
show version
```

Почему `elif`: в рамках одной условной секции может быть только один открывающий `if`. Два `if` это две разных условных секции, которые будут обрабатываться друг за другом. Секции не зависят друг от друга, поэтому значение переменной `a` проверяется два раза: в каждой из секции.

```python
In [233]: if a < 10:
     ...:     print(f"{a} меньше 10")
     ...: if a < 20:
     ...:     print(f"{a} меньше 20")
     ...: 
5 меньше 10
5 меньше 20
```

один `if` = одна условная секции. Значит будет выполнен код только того блока, условие которого будет истиной.

```python
In [234]: if a < 10:
     ...:     print(f"{a} меньше 10")
     ...: elif a < 20:
     ...:     print(f"{a} меньше 20")
     ...: 
5 меньше 10
```

## `else`

закрывающий условную секцию блок. Необязательны блок. Будет выполнен если ни одно из условий до этого (описанные в if/elif) не было истиной.

```python
In [241]: a = 15
     ...: 
     ...: if a > 20:
     ...:     print(f"{a} больше 20")
     ...: elif a < 10:
     ...:     print(f"{a} меньше 10")
     ...: else:
     ...:     print(f"{a} где-то между 10 и 20")
     ...: 
15 где-то между 10 и 20

### ===
In [61]: if vendor == "huawei":
    ...:     cmd = "display version"
    ...: elif vendor == "arista":
    ...:     cmd = "show version"
    ...: else:
    ...:     cmd = "UNKNOWN VENDOR"
```

## Тернарный оператор

В простых ситуациях можно использовать тернарный оператор, вместо развернутой формы.

<p align="center"><img src="img/ternary.png" width="500" alt=""></p>

```python
In [223]: result = True
In [223]: 'успешно' if result else 'с ошибкой'
Out[223]: 'успешно'

In [225]: print(f"скрипт выполнен {'успешно' if result else 'с ошибкой'}")
скрипт выполнен успешно

In [226]: result = False
In [227]: print(f"скрипт выполнен {'успешно' if result else 'с ошибкой'}")
скрипт выполнен с ошибкой
```
