# Словари (dict)

- [Словари (dict)](#словари-dict)
  - [Описание](#описание)
  - [Когда используются](#когда-используются)
  - [Создание](#создание)
  - [Доступ к элементам](#доступ-к-элементам)
  - [Изменение элементов](#изменение-элементов)
  - [Полезные функции и методы](#полезные-функции-и-методы)
    - [`dict.keys()`, `dict.values()`, `dict.items()` - списки ключей, значений, кортежей вида (ключ, значение)](#dictkeys-dictvalues-dictitems---списки-ключей-значений-кортежей-вида-ключ-значение)
    - [`zip()` - объединение элементов из нескольких последовательностей](#zip---объединение-элементов-из-нескольких-последовательностей)
    - [`dict.pop()` - удаление значения из словаря](#dictpop---удаление-значения-из-словаря)
    - [`dict.popitem()` - извлечение данных в виде (ключ, значение)](#dictpopitem---извлечение-данных-в-виде-ключ-значение)
    - [`dict.update()` - обновление словаря другим словарем](#dictupdate---обновление-словаря-другим-словарем)
    - [`|`, `|=`- объединение словарей](#---объединение-словарей)
    - [`in`, `not in` - проверка наличия ключа в словаре](#in-not-in---проверка-наличия-ключа-в-словаре)
    - [`dict.setdefault()` - получение значения по ключу](#dictsetdefault---получение-значения-по-ключу)
  - [`**` - распаковка](#---распаковка)
  - [`defaultdict` - словарь со значениями по умолчанию](#defaultdict---словарь-со-значениями-по-умолчанию)

## Описание

Словарь это **изменяемая** **упорядоченная** последовательность данных в виде пар "ключ-значение".  

Требования к ключам в словарях:

- Ключами могут быть только хэшируемые элементы.  
  Например `list` не является таковым, поэтому нельзя использовать список в качестве ключа. А `tuple` - хэшируемый, поэтому кортеж может быть ключом в словаре.  
- В рамках одного словаря ключи не могут повторятся.

В одном словаре можно смешить тип данных ключей. Но чаще всего используются строки в качестве ключей.

Никакой особой закономерности между ключами нет, в отличии от индексов листов и кортежей (они монотонны, т.е. идут без пропусков и отличаются от от соседних индексов на 1).

Словари используют для хранения наборы характеристик/параметров объекта.

## Когда используются

- Нужно описать параметры некоторого объекта (устройство, интерфейс и пр)
- Часто конфигурационные параметры хранят в виде словаря (можно считать это частным случаем первого пункта, конфигурация - некоторый объект)
- Передать в функцию множество параметров одним аргументом

## Создание

```python
device = {
  "name": "router1.my.lab.com",
  "ip": "192.168.1.33",
  "username": "cisco",
}
```

Тут "name", "ip", "username" это ключи словаря, а "router1.my.lab.com", "192.168.1.33", "cisco" - соответствующие им значения.

Альтернативные варианты создания словаря:

```python
device = dict(
    name="router1.my.lab.com",
    ip="192.168.1.33",
    username="cisco",
)
```

```python
device = dict.fromkeys(["name", "ip", "username"])

device
>>> {'name': None, 'ip': None, 'username': None}

device["name"] = "router1.my.lab.com"
device["ip"] = "192.168.1.33"
device["username"] = "cisco"

device
>>> {'name': 'router1.my.lab.com', 'ip': '192.168.1.33', 'username': 'cisco'}
```

```python
device = dict(
    [
        ("name", "router1.my.lab.com"),
        ("ip", "192.168.1.33"),
        ("username", "cisco"),
    ],
)
device
>>> {'name': 'router1.my.lab.com', 'ip': '192.168.1.33', 'username': 'cisco'}
```

Значениями в словаре могут быть любый данные (в том числе и изменяемые), поэтому существует и вложенность словарей.

```python
config = {
    "bar": "baz",
    "spam": 99.9,
    "answer": 42,
    "items": {
        "foo": "bar",
        "bar": "bozz",
    },
}
```

## Доступ к элементам

```python
# прямой доступ по ключу
In [26]: device["name"]
Out[26]: 'router1.my.lab.com'

# если ключа нет, то вызывается исключение
In [28]: device["password"]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
Cell In[28], line 1
----> 1 device["password"]

KeyError: 'password'
```

При обращении к несуществующему ключу вызывается исключение `KeyError`, аналог `IndexError` для последовательностей с доступом по индексу (строки/списки/...)

```python
# безопасный метод получения значения
In [31]: device.get("password")

In [32]: device.get("password", "unknown")
Out[32]: 'unknown'
```

По умолчанию при отсутствии ключа `dict.get()` возвращает `None`, но это значение можно переопределить.

## Изменение элементов

Для изменения значений по определенному ключу достаточно оператора присвоения `=`. При этом если ключа нет - он будет создан, если есть - значение будет переписано на новое.

```python
In [69]: device
Out[69]:
{'name': 'router1.my.lab.com',
'ip': '192.168.1.33',
'username': 'cisco'}

In [70]: device["password"] = "secret"
In [72]: device["username"] = "CISCO123"

In [73]: device
Out[73]: 
{'name': 'router1.my.lab.com',
 'ip': '192.168.1.33',
 'username': 'CISCO123',
 'password': 'secret'}
```

## Полезные функции и методы

### `dict.keys()`, `dict.values()`, `dict.items()` - списки ключей, значений, кортежей вида (ключ, значение)

```python
In [33]: device.keys()
Out[33]: dict_keys(['name', 'ip', 'username'])

In [34]: device.values()
Out[34]: dict_values(['router1.my.lab.com', '192.168.1.33', 'cisco'])

In [35]: device.items()
Out[35]: dict_items(
  [
    ('name', 'router1.my.lab.com'),
    ('ip', '192.168.1.33'),
    ('username', 'cisco'),
  ]
)
```

### `zip()` - объединение элементов из нескольких последовательностей

В примере функция `zip()` склеивает попарно элементы каждой последовательности и возвращает итератор (мы сразу его в list преобразуем, для упрощения), содержащий кортежи из склеенных элементов.

```python
In [48]: keys = ["name", "ip", "username"]

In [49]: values = ["router1.my.lab.com", "192.168.1.33", "cisco"]

In [50]: list(zip(keys, values))
Out[50]: 
[
  ('name', 'router1.my.lab.com'), 
  ('ip', '192.168.1.33'), 
  ('username', 'cisco'),
]
```

Из списка кортежей вида `(ключ, значение)` можно получить словарь:

```python
In [54]: dict(zip(keys, values))
Out[54]: 
{
  'name': 'router1.my.lab.com',
  'ip': '192.168.1.33',
  'username': 'cisco',
}
```

Это частный случай применения `zip()`. Еще примеры

```python
In [55]: l1 = [1, 2, 3]
In [56]: l2 = [4, 5, 6]
In [57]: l3 = [7, 8, 9]

In [58]: list(zip(l1, l2, l3))
Out[58]: 
[
  (1, 4, 7),
  (2, 5, 8),
  (3, 6, 9),
]
```

```python
In [61]: list(
    ...:     zip(
    ...:         ("a", 1),
    ...:         ("b", 2),
    ...:         ("c", 3),
    ...:         ("d", 4),
    ...:     )
    ...: )
Out[61]:
[
  ('a', 'b', 'c', 'd'),
  (1, 2, 3, 4),
]

# или применяя распаковку
In [59]: input_data = [("a", 1), ("b", 2), ("c", 3), ("d", 4)]

In [60]: list(zip(*input_data))
Out[60]: [('a', 'b', 'c', 'd'), (1, 2, 3, 4)]
```

### `dict.pop()` - удаление значения из словаря

`dict.pop()` похож на метод `list.pop()` с той разницей, что в словарях нужно указывать ключ, а не индекс.

```python
In [74]: device.pop("password")
Out[74]: 'secret'

In [75]: device.pop("password")
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
Cell In[75], line 1
----> 1 device.pop("password")

KeyError: 'password'

# если указать значение по умолчанию, которое будет 
# возвращаться при отсутствии ключа, то исключения не будет
In [81]: device.pop("password", None)

In [82]: device.pop("password", "no key")
Out[82]: 'no key'
```

### `dict.popitem()` - извлечение данных в виде (ключ, значение)

`dict.popitem()` аналог `list.pop()` - извлекает последние добавленные данные (LIFO) и возвращает кортеж (ключ, значение)

```python
In [84]: device
Out[84]: {'ip': '192.168.1.33', 'username': 'CISCO123'}

In [85]: device.popitem()
Out[85]: ('username', 'CISCO123')
```

### `dict.update()` - обновление словаря другим словарем

Назначение аналогично `list.extend()` - расширить словарь другим словарем. Но так как ключи должны быть уникальны, то:

- если ключа в исходном словаре нет, то новая пара (ключ, значение) просто дописывается в словарь
- при совпадении ключей происходит перезапись исходных значений новыми,  значения заменяются

```python
In [89]: device
Out[89]:
{'name': 'router1.my.lab.com',
'ip': '192.168.1.33',
'username': 'cisco'}

In [90]: device.update({"ip": "192.168.1.233", "password": "secret"})

In [91]: device
Out[91]: 
{'name': 'router1.my.lab.com',
 'ip': '192.168.1.233',
 'username': 'cisco',
 'password': 'secret'}
```

### `|`, `|=`- объединение словарей

Начиная с python3.9 вместо `dict.update()` можно использовать

- `|` - объединяет словари (так же, как `dict.update()`), но не модифицирует исходный словарь, а возвращает новый
- `|=` - объединяет словарь и обновляет исходный (полный аналог `dict.update()`)

```python
In [96]: device |= {"ip": "192.168.222.222", "password": "secret!!"}

In [97]: device
Out[97]: 
{'name': 'router1.my.lab.com',
 'ip': '192.168.222.222',
 'username': 'cisco',
 'password': 'secret!!'}
```

### `in`, `not in` - проверка наличия ключа в словаре

Проверка наличия или отсутствия ключа в словаре

```python
In [103]: device
Out[103]: 
{'name': 'router1.my.lab.com',
 'ip': '192.168.1.233',
 'username': 'cisco',
 'password': 'secret!!',
 'model': None}

In [104]: "version" in device
Out[104]: False

In [105]: "ip" in device
Out[105]: True

In [106]: "location" not in device
Out[106]: True
```

### `dict.setdefault()` - получение значения по ключу

отличия от `dict.get()` в том, что в случае отсутствия ключа, не вызывает исключение, а создает ключ со значением по умолчанию (`None`)

```python
In [99]: device
Out[99]: 
{'name': 'router1.my.lab.com',
 'ip': '192.168.1.233',
 'username': 'cisco',
 'password': 'secret!!'}

In [100]: device.setdefault("model")

In [101]: device
Out[101]: 
{'name': 'router1.my.lab.com',
 'ip': '192.168.1.233',
 'username': 'cisco',
 'password': 'secret!!',
 'model': None}

In [102]: device.setdefault("ip")
Out[102]: '192.168.1.233'
```

## `**` - распаковка

Для списков/кортежей (доступ по индексу) распаковка с использованием `*` рассмотрена в [отдельной части](/015.unpacking/015.unpacking.md). Для словарей (доступ по ключу) существую аналогичный процесс, но применяется оператор `**`. В результате получаются пары ключ=значение, а не просто значения, как в случае с `*` и распаковкой списков.

```python
# передача именованных аргументов без распаковки
conn = Scrapli(
    host="172.18.0.11",
    auth_username="scrapli",
    auth_password="scrapli",
    auth_strict_key=False,
    platform="cisco_iosxe",
)

# при передачи аргументов через распаковку словаря, можно не только 
# улучшить читаемость, но и вынести постоянную часть в константы 

SCRAPLI_TEMPLATE = {
    "auth_username": "scrapli",
    "auth_password": "scrapli",
    "auth_strict_key": False,
    "platform": "cisco_iosxe",
}

# перед использованием создаем итоговый словарь
device = SCRAPLI_TEMPLATE | {"host": "192.168.5.113"}

conn = Scrapli(**device)
```

Так же распаковку можно использовать для объединения словарей:

```python
access = {
    "name": "rt1",
    "ip": "192.168.1.1",
}

creds = {
    "username": "cisco",
    "password": "cisco",
}

device = {**device, **creds}
device
>>>
{
  'name': 'rt1',
  'ip': '192.168.1.1',
  'username': 'cisco',
  'password': 'cisco',
}
```

## `defaultdict` - словарь со значениями по умолчанию

Наш словарь имеет структуру (списки в качестве значений):

```python
In [107]: device = {
     ...:     "name": "router1.my.lab.com",
     ...:     "gi0/0": ["192.168.0.1", "192.168.0.2"],
     ...:     "gi0/1": ["192.168.1.1"],
     ...: }
```

При начале обработки очередного интерфейса перед добавлением первого ip адреса нам нужно создать ключ c именем интерфейса и пустым списком в качестве значения. Но сделать это только один раз, что бы при следующих действиях у нас список ip не поменялся на пустой. И после этого можно добавлять ip в список.

```python
intf_name = "gi0/2"
ip = "192.168.2.1"
if intf_name not in device:
    # инициализируем пустой список
    device[intf_name] = []
# добавляем в список значение
device[intf_name].append(ip)
```

вариант решения через `dict.setdefault()`

```python
intf_name = "gi0/3"

ip = "192.168.3.1"
device.setdefault(intf_name, []).append(ip)

ip = "192.168.3.2"
device.setdefault(intf_name, []).append(ip)
```

Но это настолько частая операция, что сделали тип `defaultdict` и включили его в стандартную библиотеку. Этот тип позволяет при создании словаря словаря задать значение по умолчанию для значений.

```python
In [119]: from collections import defaultdict

In [120]: device = defaultdict(list)
In [121]: device["name"] = "router1.my.lab.com"
In [122]: device["gi0/0"].append("192.168.0.1")

In [123]: device
Out[123]: 
defaultdict(
  list, 
  {
    'name': 'router1.my.lab.com', 
    'gi0/0': ['192.168.0.1'],
  },
)

In [124]: device["gi0/0"].append("192.168.0.2")
In [125]: device["gi0/1"].append("192.168.1.1")
In [126]: device["gi0/2"].append("192.168.2.1")
In [127]: device["gi0/2"].append("192.168.2.2")

In [128]: device
Out[128]: 
defaultdict(
  list,
  {
    'name': 'router1.my.lab.com',
    'gi0/0': ['192.168.0.1', '192.168.0.2'],
    'gi0/1': ['192.168.1.1'],
    'gi0/2': ['192.168.2.1', '192.168.2.2'],
  },
)
```
