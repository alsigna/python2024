# Аннотация типов

- [Аннотация типов](#аннотация-типов)
  - [Описание](#описание)
  - [Аннотация переменных](#аннотация-переменных)
  - [Аннотация функций](#аннотация-функций)
  - [Специальные типы](#специальные-типы)
    - [`Any`](#any)
    - [`Literal`](#literal)
    - [`Final`](#final)
    - [`Iterator`, `Iterable`](#iterator-iterable)
    - [`Callable`](#callable)

## Описание

Python язык с неявной динамической строгой типизацией:

- неявная - при объявлении переменной не нужно указывать её тип
- динамическая - тип переменной определяется во время выполнения программы, в ходе работы программы можно в одну переменную складывать данные различных типов
- строгая - нельзя совершать операции над данными разных типов

Аннотация типов используется для обозначения типа для переменных и функций (как параметров, так и возвращаемых значений). Аннотация не обеспечивает проверку типов на уровне интерпретатора. Аннотация предназначена для разработчика, IDE, линтеров и прочее.

## Аннотация переменных

Для аннотации переменных используется синтаксис `<имя_переменной>: <тип> = <значение>`, например:

```python
force: bool = True
delay: int = 30
devices: list = ["rt1", "rt2"]
```

Если переменная может быть нескольких типов, то это так же можно указать через `|`:

```python
# delay это либо integer либо NoneType
delay: int | None = 30
```

Для последовательностей можно указывать не только тип самой последовательности, но и тип элементов, из которых эта последовательность состоит. При этом глубину аннотации определяет разработчик самостоятельно:

```python
# list[str] - список со строковыми элементами
devices: list[str] = ["rt1", "rt2"]

# dict[str, dict] - словарь, в котором ключи - строки, а значения - словари
scrapli: dict[str, dict[str, str | int]] = {
    "rt1": {
        "port": 22,
        "transport": "system",
    },
}
```

## Аннотация функций

Для аннотации параметров функций используются те же правила, что и для аннотации переменных. Для аннотации возвращаемого результата используется символ `->`:

```python
def get_device_output(device: str, command: str, *, timeout: int = 30) -> str:
    pass
```

## Специальные типы

Наиболее часто используемые типы данных можно аннотировать встроенными типами (int, str, bool) как показано выше, но для более сложных случаем потребуется подключения библиотеки `typing`, в которой содержится большое число специальных типов. Python развивается и меняется, аннотация не исключение, поэтому есть "старые" и "новые" способы сделать одно и то же действие, например:

- до python3.9 аннотация коллекция производилась с помощью библиотеки `typing`, с 3.9 можно использовать встроенный тип `list`

    ```python
    from typing import List

    # до 3.9
    routers: List[str] = ["rt1", "rt2"]
    # c 3.9
    switches: list[str] = ["sw1", "sw2"]
    ```

- до python3.10 аннотация несколькими типами производилась через класс `Union` (а для комбинации с `None` был дополнительный класс `Optional`), с 3.10 можно использовать символ `|` для комбинации разных типов:

```python
from typing import Optional, Union

# до 3.10 в Union через запятую перечисляем возможные типы
delay: Union[int, None] = 30
# до 3.10 для комбинации с None вместо Union можно использовать Optional
delay: Optional[int] = 30
# с 3.10 типы можно перечислять через |
delay: int | None = 30
```

### `Any`

Означает любой тип.

```python
from typing import Any

result: Any = "OK"
```

### `Literal`

Одно из перечисленных значений.

```python
def get_command_output(
    hostname: str,
    command: str,
    transport: Literal["ssh", "telnet"],
) -> str:
    pass
```

### `Final`

не можем менять значение или переопределять переменную

```python
from typing import Final

MIN_LENGTH: Final[int] = 2

# тут IDE должен начать ругаться
MIN_LENGTH += 1
```

### `Iterator`, `Iterable`

Итератор (может быть передан в `next` для получения очередного элемента) и итерируемый объект (может быть преобразован в итератор через `iter`)

```python
from typing import Iterable, Iterator

l = [1, 3, 2, -4, 5, 10, 20]

isinstance(l, Iterable)
True

isinstance(l, Iterator)
False

isinstance(iter(l), Iterable)
True

isinstance(iter(l), Iterator)
True

def foo(seq: Iterable[int]) -> None:
    pass
```

### `Callable`

вызываемый объект (функция):

```python
from typing import Callable

# [[int, int], str]: [int, int] - два входных параметра типа int, str - тип возвращаемого значения
def foo(f: Callable[[int, int], str]) -> bool: 
    pass
```
