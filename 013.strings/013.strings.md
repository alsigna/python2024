# Строки (str)

- [Строки (str)](#строки-str)
  - [Описание](#описание)
  - [Создание](#создание)
    - [Текст в одну строку](#текст-в-одну-строку)
    - [Многостроковый текст](#многостроковый-текст)
    - [Экранирование](#экранирование)
    - [Байтовые строки](#байтовые-строки)
  - [Доступ к элементам (индекс и срезы)](#доступ-к-элементам-индекс-и-срезы)
    - [Индекс](#индекс)
    - [Срез](#срез)
  - [Полезные функции и методы](#полезные-функции-и-методы)
    - [`len()` - получить длину строки](#len---получить-длину-строки)
    - [`str.find()` - поиск подстроки в строке](#strfind---поиск-подстроки-в-строке)
    - [`str.index()` - поиск подстроки в строке](#strindex---поиск-подстроки-в-строке)
    - [`str.replace()` - замена по шаблону](#strreplace---замена-по-шаблону)
    - [`str.split()` - разделение строки](#strsplit---разделение-строки)
    - [`str.strip()` - удаление символов в начале и конце строки](#strstrip---удаление-символов-в-начале-и-конце-строки)
    - [`str.startswith()` - проверить начало строки на совпадению шаблону](#strstartswith---проверить-начало-строки-на-совпадению-шаблону)
    - [`str.endswith()` - проверить конец строки на совпадению шаблону](#strendswith---проверить-конец-строки-на-совпадению-шаблону)
    - [`str.join()` - собрать строку из списка](#strjoin---собрать-строку-из-списка)
    - [`str.isdigit()` - проверить, что строка состоит только из цифр](#strisdigit---проверить-что-строка-состоит-только-из-цифр)
    - [`str.lower()`, `str.upper()` - преобразовать регистр](#strlower-strupper---преобразовать-регистр)
    - [`str.zfill()` - заполняет строку нулями](#strzfill---заполняет-строку-нулями)
    - [`+` - конкатенация строк](#---конкатенация-строк)
    - [`in` - проверить вхождение подстроки в строку](#in---проверить-вхождение-подстроки-в-строку)
  - [Форматирование строк](#форматирование-строк)
    - [legacy метод](#legacy-метод)
    - [`str.format()` - форматирование строки](#strformat---форматирование-строки)
    - [`f-string` - использование f-строк](#f-string---использование-f-строк)
    - [Модификаторы подставляемых значений](#модификаторы-подставляемых-значений)

## Описание

Строки это последовательность символов. К ним применимы некоторые методы других последовательностей. Например срезы или доступ по индексу.

Строки это неизменяемый тип. При попытке изменить строку в памяти будет созданы новые данные и в переменную запишется новый адрес на эти данные, а старые данные удалятся.

## Создание

### Текст в одну строку

```python
s = 'hello'

s = "some text"

s = str(456)

s = "my " "text"

s = "text \
on one \
line"""
```

### Многостроковый текст

```python
s = """multiline
text,
3rd line"""

config = (
    "interface Tunnel2\n"
    "  description {{ interfaces.tunnel.1.description }}\n"
    "  ip address {{ interfaces.tunnel.1.ip }} {{ interfaces.tunnel.1.mask }}\n"
    "  ip nhrp network-id {{ interfaces.tunnel.1.network_id }}\n"
)

from textwrap import dedent
s = dedent(
    """
    interface Tunnel2
        description {{ interfaces.tunnel.1.description }}
        ip address {{ interfaces.tunnel.1.ip }} {{ interfaces.tunnel.1.mask }}
        ip nhrp network-id {{ interfaces.tunnel.1.network_id }}
    """
)
```

### Экранирование

```python
In [42]: s = "C:\temp\new"
In [43]: s
Out[43]: 'C:\temp\new'
In [44]: print(s)
C:      emp
ew

In [45]: s = "C:\\temp\\new"
In [46]: print(s)
C:\temp\new

In [47]: s = r"C:\temp\new"
In [48]: print(s)
C:\temp\new
```

### Байтовые строки

Это строки, которые содержат "сырые". Если обычная строка может содержать любые символы Unicode, байтовые строки могут содержать только байты в диапазоне от 0 до 255. Где можно встретить - вывод с оборудования.

```python
In [49]: s = b"interface loopback0"
```

## Доступ к элементам (индекс и срезы)

### Индекс

Строка это упорядоченная последовательность. Доступ к одиночным элементам (символам) возможен по индексу. Индекс это порядковый номер символа в строке.

- нумерация начинается с нуля
- для указания индекса используются квадратные скобки
- положительный индекс (0, 1, 2, ...) - считаем слева направо (0 - первый символ, 1 - второй символ)
- отрицательный индекс (-1, -2, ...) - считаем справа налево (-1 - последний символ, -2 - предпоследний символ, -3 - третий с конца)

```python
In [1]: intf = "interface loopback0"
In [2]: intf[-1]
Out[2]: '0'
In [3]: intf[-2]
Out[3]: 'k'
In [4]: intf[0]
Out[4]: 'i'
```

### Срез

Срез это подмножество символов строки, которое задаётся следующим образом: my_string[START:STOP:STEP].  

- START - начало среза, по умолчанию 0
- STOP - конец среза. По умолчанию равен длине объекта. НЕ включается в результат!
- STEP - шаг среза. По умолчанию 1.

> START/STOP/STEP могут быть отрицательными, тогда мы инвертируем логику и начинаем считать справа налево

```python
In [7]: s = "interface"

In [8]: s[::]  # все значения по умолчанию, поэтому вернется вся строка целиком
Out[8]: 'interface'

In [9]: s[3::]  # до конца, начиная с четвертого символа (индекс = 3)
Out[9]: 'erface'

In [10]: s[:3:]  # первые три символа
Out[10]: 'int'

In [11]: s[::2]  # идем через символ, т.е. 0, 2, 4, 6, и т.д.
Out[11]: 'itrae'
```

> Если STEP стандартный (1), то эту часть среза можно опустить (так обычно и делают), и записывать `s[3:]` вместо `s[3::]`

```python
In [12]: s[3:]
Out[12]: 'eface'

In [13]: s[3::]
Out[13]: 'eface'

In [14]: s[:3:]
Out[14]: 'int'

In [15]: s[:3]
Out[15]: 'int'
```

отрицательные срезы:

```python
In [7]: s = "interface"

In [16]: s[:-2]  # все, кроме последних двух символов
Out[16]: 'interfa'

In [18]: s[1:-2]  # начиная со второго символа и до последних двух
Out[18]: 'nterfa'

In [31]: s[-3:0:-1]  # с третьего с конца до начала
Out[31]: 'afretn'
```

## Полезные функции и методы

### `len()` - получить длину строки

```python
In [34]: s = "interface loopback0"
In [41]: len(s)
Out[41]: 19
```

### `str.find()` - поиск подстроки в строке

```python
In [51]: s = "interface loopback0"

In [52]: s.find("loop")
Out[52]: 10

In [53]: s[10:]
Out[53]: 'loopback0'
```

вернет `-1` если подстрока не найдена

### `str.index()` - поиск подстроки в строке

Аналогична `str.find()`, только вызовет ValueError если подстрока не найдена.

### `str.replace()` - замена по шаблону

```python
In [57]: s = "interface loopback0"
In [58]: s.replace("loopback0", "GigabitEthernet0/0")
Out[58]: 'interface GigabitEthernet0/0'
```

### `str.split()` - разделение строки

```python
In [60]: s = "192.168.42.51"

In [61]: s.split(".")
Out[61]: ['192', '168', '42', '51']
```

### `str.strip()` - удаление символов в начале и конце строки

```python
In [62]: s = "   load-interval 30   "

In [63]: s.strip()
Out[63]: 'load-interval 30'
```

### `str.startswith()` - проверить начало строки на совпадению шаблону

```python
In [68]: s = "sw2.msk.my.net.ru"

In [69]: s.startswith("sw")
Out[69]: True
```

### `str.endswith()` - проверить конец строки на совпадению шаблону

Аналогична `str.startswith()`, только проверяет окончание строки.

### `str.join()` - собрать строку из списка

```python
In [80]: ".".join(["192", "168", "42", "55"])
    ...: 
Out[80]: '192.168.42.55'
```

### `str.isdigit()` - проверить, что строка состоит только из цифр

```python
In [81]: "5".isdigit()
Out[81]: True
```

### `str.lower()`, `str.upper()` - преобразовать регистр

```python
In [87]: "Loopback".upper()
Out[87]: 'LOOPBACK'

In [88]: "LoopBack".lower()
Out[88]: 'loopback'
```

### `str.zfill()` - заполняет строку нулями

```python
In [92]: bin(10)[2:].zfill(8)
Out[92]: '00001010'
```

### `+` - конкатенация строк

```python
block = "interface"
name = "Loopback0"

block + " " + name
'interface Loopback0'
```

### `in` - проверить вхождение подстроки в строку

```python
command = "ip nhrp registration no-unique"

"registration" in command
>>> True

"reg" in command
>>> True

"hello" in command
>>> False
```

## Форматирование строк

### legacy метод

```python
In [104]: intf_type = "Loopback"

In [105]: "interface %s%d" % (intf_type, 0)
Out[105]: 'interface Loopback0'
```

### `str.format()` - форматирование строки

```python
# позиционные аргументы
In [109]: template = "interface {}{}"
In [110]: template.format("Loopback", "100")
Out[110]: 'interface Loopback100'

# именованные аргументы
In [106]: template = "interface {name}{number}"
In [107]: template.format(number="100", name="Loopback")
Out[107]: 'interface Loopback100'
```

### `f-string` - использование f-строк

Начиная с python3.6.

- Улучшают читаемость кода
- Имеют быструю производительность
- Задаются литералом `f` перед строкой. Внутри строки в `{}` можно записывать код Python, который будет выполнен, а результат подставлен в строку.

```python
In [211]: tunnel_name = "Tunnel123"

In [212]: f"interface {tunnel_name}"
Out[212]: 'interface Tunnel123'

In [213]: number = 5
In [215]: f"{number} в двоичной системе {bin(number)}"
Out[215]: '5 в двоичной системе 0b101'

In [216]: f"куб числа {number} равен {number ** 3}"
Out[216]: 'куб числа 5 равен 125'

In [217]: interfaces = ["Loopback0", "Tunnel123"]
In [218]: f"interface {interfaces[1]}"
Out[218]: 'interface Tunnel123'

In [219]: f"interface {interfaces[1].upper()}"
Out[219]: 'interface TUNNEL123'

In [227]: f"{f"${1 / 3:.3f}":-^10s}"  # вложенные f-строки
Out[227]: '--$0.333--'
```

### Модификаторы подставляемых значений

При форматировании строки с использованием `str.format()` или `f-string` есть возможность указать модификаторы подставляемых значений.

Используется следующий формат:  
`{[<name>][!<conversion>][:<format_spec>]}`

- name - имя аргумента (можно опустить, если используются позиционные аргументы)
- conversion - способ преобразования объекта в строку:
  - `!s` - str()
  - `!r` - repr()
- format_spec - как форматировать значение перед вставкой в итоговою строку.  
  сам формат имеет следующий вид `:[[<fill>]<align>][<width>][.<prec>][<type>]` (не полный вариант):
  - fill - символ заполнения
  - align - выравнивание
    - `^` - по центру
    - `<` - по левому краю
    - `>` - по правому краю (по умолчанию)
  - width - минимальная ширина строки
  - prec - точность
  - type - тип представления:
    - `f` - с плавающей точкой
    - `b` - двоичная система
    - `d` - десятеричная
    - `h` - шестнадцатеричная

```python
# преобразование в двоичную систему
In [147]: f"{255:b}"  # b = бинарное представление
Out[147]: '11111111'

In [161]: f"{15:b}"
Out[161]: '1111'

In [162]: f"{15:8b}"  # 8 - ширина строки. 
Out[162]: '    1111'

In [171]: f"{15:^8b}"  # выравнивание
Out[171]: '  1111  '

In [172]: f"{15:<8b}"
Out[172]: '1111    '

In [173]: f"{15:>8b}"
Out[173]: '    1111'

In [174]: f"{15:0^8b}"  # заполним пробелы нулями
Out[174]: '00111100'

In [177]: f"{1/3}"
Out[177]: '0.3333333333333333'

In [178]: f"{1/3:.2f}"  # округление до двух знаков
Out[178]: '0.33'

In [208]: "Число {0} в двоичной системе это {0:b}".format(36)
Out[208]: 'Число 36 в двоичной системе это 100100'

In [210]: "Число {0:d} в двоичной системе это {0:b}".format(0b100100)
Out[210]: 'Число 36 в двоичной системе это 100100'
```
