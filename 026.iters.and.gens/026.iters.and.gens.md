# Итераторы и генераторы

- [Итераторы и генераторы](#итераторы-и-генераторы)
  - [Описание](#описание)
  - [Итератор](#итератор)
  - [Итерируемый объект](#итерируемый-объект)
  - [Генератор](#генератор)
    - [Генераторное выражение](#генераторное-выражение)
    - [Функция с `yield`](#функция-с-yield)
  - [Пример генератора](#пример-генератора)
  - [Особенности](#особенности)

## Описание

Когда необходимо перебирать какие-то последовательности (списки/кортежи/...), то обычно упоминаются два понятия: итератор и генератор.

## Итератор

Итератор это тип объекта, который позволяет обойти все элементы своей коллекции использую встроенную функцию `next`. Для создания итератора необходимо создать класс, который реализует протокол итератора, т.е. имеет специальные методы `__iter__` и `__next__`. Итераторы рассматривать не будем, так как это сложная конструкция.

## Итерируемый объект

Итерируемый объект это экземпляр класса, поддерживающего протокол итератора (работает с функцией `next`). Уже знакомые нам последовательности, сами по себе не являются итерируемыми объектами:

```python
l = [1, 3, 2, -4, 5, 10, 20]

next(l)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
----> 1 next(l)

TypeError: 'list' object is not an iterator
```

но такие последовательности могут быть преобразованы в итерируемый объект с использованием встроенной функции `iter`:

```python
my_iter_obj = [1, 3, 2, -4, 5, 10, 20]
my_iter_obj = iter(my_iter_obj)

next(my_iter_obj)
# >>> 1

next(my_iter_obj)
# >>> 3
```

Когда из последовательности вынут последний элемент, то очередной вызов `next` приведёт к исключению `StopIteration`, которое означает, что последовательность закончилась.

```python
next(my_iter_obj)
# >>> 20

next(my_iter_obj)
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
----> 1 next(my_iter_obj)

StopIteration: 
```

Основное применение итерируемых объектов: циклы. Но их реализация скрывает особенности работы с итерируемыми объектами, например обработка исключения, получения итерируемого объекта из списка.

## Генератор

Генератор это более простой способ получить итератор. Есть два варианта создания генератора:

- генераторное выражение
- функция с `yield` вместо `return`

### Генераторное выражение

Уже знакомый по list comprehension подход может быть использован для получения генераторного выражения. В нем используются круглые скобки `()`, вместо квадратных `[]`:

```python
devices = [f"rt{i:02}" for i in range(5)]
devices
# >>> ['rt00', 'rt01', 'rt02', 'rt03', 'rt04']
type(devices)
# >>> list


devices = (f"rt{i:02}" for i in range(5))
devices
# >>> <generator object <genexpr> at 0x106cecfb0>
type(devices)
# >>> generator

next(devices)
# >>> 'rt00'
next(devices)
# >>> 'rt01'
next(devices)
# >>> 'rt02'
```

### Функция с `yield`

Если логика последовательности сложная и не умещается в генераторное выражение, можно использовать функцию с `yield`. Инструкция `return` возвращает результат работы функции и завершает её, все локальные данные удаляются, `yield` возвращает данные и "замораживает" функцию до следующего к ней обращения.

```python
def get_device():
    for i in range(5):
        yield f"rt{i:02}"

devices = get_device()
type(devices)
# >>> generator
next(devices)
# >>> 'rt00'
next(devices)
# >>> 'rt01'
next(devices)
# >>> 'rt02'
```

## Пример генератора

Делаем плоский список.

```python
def flatten_list(seq):
    for elem in seq:
        if isinstance(elem, list):
            for nested_elem in flatten_list(elem):
                yield nested_elem
        else:
            yield elem

l = [1, 2, 3]
list(flatten_list(l))
# >>> [1, 2, 3]

l = [1, [21, 22], 3]
list(flatten_list(l))
# >>> [1, 21, 22, 3]

l = [1, [21, [221, 222]], 3, [41, 42]]
list(flatten_list(l))
# >>> [1, 21, 221, 222, 3, 41, 42]
```

## Особенности

- генераторы (и итераторы) отдают очередной элемент по требованию, т.е. не хранят всю последовательность в памяти как это делает, например, список, тем самым уменьшая потребление ресурсов и увеличивая скорость доступа к элементу
- получить элементы из генератора можно только один раз, затем генератор "опустошается" и его нужно снова инициализировать
- `list` позволяет получить все элементы из генератора (пройтись по нему) и сохранить их в список. `tuple`, `dict`, `set` работают аналогично
- многие стандартные функции, которые раньше возвращали список (типа `map`, `zip` и прочее) сейчас возвращают итерируемый объект. Поэтому, что бы получить список, этот объект оборачивается в `list`: `list(map(str, [1, 2, 3]))`
- основное отличие генератора от итератора в способе создания. Итератор более сложная конструкция, требующая понимания протокола итератора и больше кода, чем генератор. Генератор создается более простым и удобным способом.
